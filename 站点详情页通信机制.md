# 站点详情页通信机制设计文档

## 1. 整体架构

站点详情页是一个功能丰富的页面，主要包含以下四个核心部分：

1. **站点信息区**：由站点列表自动传入的基本信息
2. **设备信息区**：由后端API推送，可通过WebSocket控制
3. **实时数据区**：由后端API推送，根据数据类型动态渲染不同的UI组件
4. **告警信息和历史趋势区**：使用API调用获取数据

站点详情页面能够处理多种数据类型，并根据数据类型选择不同的渲染方式，甚至决定是否显示某些组件，实现高度的动态适配。后端可能传送的数据类型包括：

- **传感器数据**：进水数据(indata)和出水数据(outdata)
- **能耗监控数据**：各设备能耗统计(energy_stats)
- **设备运行时间数据**：设备运行时间统计(equipments)
- **工艺参数数据**：工艺参数监控(process_parameters)
- **报警信息数据**：当前报警(active_alarms)
- **化验数据**：水质化验结果(lab_results)
- **设备健康状态**：设备健康状态(equipment_health)
- **生产指标**：处理生产指标(production_metrics)
- **设备控制数据**：设备控制(control_devices)
- **阀门控制数据**：阀门控制(control_valves)
- **频率设置数据**：频率设置(freq_control)

每种数据类型都有不同的结构和属性，需要不同的渲染方式，页面需要能够动态适应这些不同的数据类型。

### 1.1 技术栈

- **前端框架**：React
- **UI组件库**：Ant Design
- **状态管理**：React Hooks (useState, useEffect, useCallback)
- **路由管理**：React Router
- **HTTP请求**：Axios (通过api拦截器)
- **WebSocket**：原生WebSocket API (通过WebSocketContext)
- **样式管理**：CSS Modules (SCSS)

### 1.2 系统架构图

```
┌─────────────────────────────────────────────────────────────┐
│                      站点详情页 (SiteDetail)                  │
├───────────────┬───────────────┬───────────────┬─────────────┤
│  站点信息区    │   设备信息区   │   实时数据区   │ 告警/趋势区  │
│  (静态数据)    │ (WebSocket控制)│  (API推送)    │  (API调用)   │
├───────────────┴───────────────┴───────────────┴─────────────┤
│                       通信层                                  │
├─────────────────────────┬───────────────────────────────────┤
│        HTTP API         │           WebSocket               │
│  (获取数据, 备用控制)     │       (设备控制, 命令反馈)         │
├─────────────────────────┴───────────────────────────────────┤
│                       后端服务                                │
│                   (Node-RED)                                │
└─────────────────────────────────────────────────────────────┘
```

## 2. 通信机制

站点详情页采用了双重通信机制，结合了HTTP API和WebSocket的优势：

### 2.1 HTTP API（数据获取）

HTTP API主要用于获取站点信息、设备状态和实时数据：

```javascript
const response = await api.get(`/api/sites/${id}`);
```

#### 2.1.1 API响应数据结构

从API响应中提取的数据包括：
```javascript
{
  "id": "123",
  "name": "某污水处理站",
  "address": "某省某市某区某街道",
  "status": "normal", // normal, warning, error, offline
  "capacity": "5000", // 处理能力
  "capacityUnit": "吨/日",
  "description": "站点描述信息",
  "departments": ["运维部", "工程部"],
  "lastUpdate": "2023-05-20T08:30:00Z",

  // 设备控制数据 (control_devices)
  "devices": [
    {
      "id": "d001",
      "name": "1号水泵",
      "status": "running", // running, stopped, error
      "location": "进水区",
      "lastUpdate": "2023-05-20T08:25:00Z",
      "type": "pump" // 设备类型
    },
    // 更多设备...
  ],

  // 频率设置数据 (freq_control)
  "deviceFrequency": [
    {
      "id": "f001",
      "name": "1号变频器",
      "hz": 45.5, // 当前频率
      "sethz": 50.0, // 设定频率
      "status": 1, // 1: 运行中, 0: 已停止
      "min": 0, // 最小频率
      "max": 60 // 最大频率
    },
    // 更多频率设备...
  ],

  // 阀门控制数据 (control_valves)
  "isValve": [
    {
      "id": "v001",
      "name": "进水阀",
      "status": 1, // 1: 已打开, 0: 已关闭
      "location": "进水区",
      "type": "gate" // 阀门类型：gate(闸阀), ball(球阀), etc.
    },
    // 更多阀门...
  ],

  // 传感器数据 - 进水数据 (indata)
  "inData": [
    {
      "id": "in001",
      "name": "进水流量",
      "data": 125.5,
      "dataType": "number", // 数据类型：number, boolean, string, enum
      "dw": "m³/h", // 单位
      "alarm": 0, // 0: 正常, 1: 异常
      "min": 0, // 最小值（可选）
      "max": 500, // 最大值（可选）
      "enumValues": null // 枚举值（可选）
    },
    {
      "id": "in002",
      "name": "进水阀状态",
      "data": 1,
      "dataType": "boolean", // 布尔类型
      "alarm": 0
    },
    {
      "id": "in003",
      "name": "水质等级",
      "data": "2",
      "dataType": "enum", // 枚举类型
      "enumValues": {
        "1": { "label": "优", "color": "green" },
        "2": { "label": "良", "color": "blue" },
        "3": { "label": "一般", "color": "orange" },
        "4": { "label": "差", "color": "red" }
      },
      "alarm": 0
    },
    // 更多进水数据...
  ],

  // 传感器数据 - 出水数据 (outdata)
  "outData": [
    {
      "id": "out001",
      "name": "出水COD",
      "data": 45.2,
      "dataType": "number",
      "dw": "mg/L", // 单位
      "alarm": 0, // 0: 正常, 1: 异常
      "min": 0,
      "max": 100
    },
    // 更多出水数据...
  ],

  // 能耗监控数据 (energy_stats)
  "energy_stats": [
    {
      "id": "e001",
      "deviceName": "1号水泵",
      "current": 10.5, // 电流
      "voltage": 380, // 电压
      "power": 5.2, // 功率
      "consumption": 125.6, // 累计耗电量
      "dataType": "energy",
      "unit": "kWh", // 单位
      "alarm": 0
    },
    // 更多能耗数据...
  ],

  // 设备运行时间数据 (equipments)
  "equipments": [
    {
      "id": "eq001",
      "name": "1号水泵",
      "runningTime": 1250.5, // 运行时间
      "startCount": 35, // 启动次数
      "lastStartTime": "2023-05-20T06:30:00Z", // 最后启动时间
      "dataType": "runtime",
      "unit": "h", // 单位
      "alarm": 0
    },
    // 更多设备运行时间数据...
  ],

  // 工艺参数数据 (process_parameters)
  "process_parameters": [
    {
      "id": "pp001",
      "name": "SBR反应时间",
      "value": 120,
      "dataType": "number",
      "unit": "min", // 单位
      "min": 90,
      "max": 180,
      "alarm": 0
    },
    {
      "id": "pp002",
      "name": "工艺模式",
      "value": "2",
      "dataType": "enum",
      "enumValues": {
        "1": { "label": "常规模式", "color": "blue" },
        "2": { "label": "节能模式", "color": "green" },
        "3": { "label": "应急模式", "color": "red" }
      },
      "alarm": 0
    },
    // 更多工艺参数数据...
  ],

  // 报警信息数据 (active_alarms)
  "active_alarms": [
    {
      "id": "a001",
      "device": "1号水泵",
      "message": "电流过高",
      "level": "warning", // warning, error
      "time": "2023-05-20T07:15:00Z",
      "acknowledged": false // 是否已确认
    },
    // 更多告警...
  ],

  // 化验数据 (lab_results)
  "lab_results": [
    {
      "id": "lab001",
      "name": "COD",
      "value": 45.2,
      "dataType": "number",
      "unit": "mg/L",
      "standard": 50, // 标准值
      "sampleTime": "2023-05-19T10:00:00Z", // 采样时间
      "reportTime": "2023-05-19T14:30:00Z", // 报告时间
      "location": "出水口",
      "alarm": 0
    },
    // 更多化验数据...
  ],

  // 设备健康状态 (equipment_health)
  "equipment_health": [
    {
      "id": "h001",
      "deviceName": "1号水泵",
      "healthScore": 85, // 健康得分
      "dataType": "number",
      "status": "good", // good, normal, warning, danger
      "maintenanceDue": "2023-08-20", // 下次维护时间
      "issues": ["轴承磨损", "需要更换密封圈"],
      "alarm": 0
    },
    // 更多设备健康状态数据...
  ],

  // 生产指标 (production_metrics)
  "production_metrics": [
    {
      "id": "pm001",
      "name": "日处理水量",
      "value": 4500,
      "dataType": "number",
      "unit": "吨/日",
      "target": 5000, // 目标值
      "alarm": 0
    },
    {
      "id": "pm002",
      "name": "处理达标率",
      "value": 98.5,
      "dataType": "number",
      "unit": "%",
      "target": 95, // 目标值
      "alarm": 0
    },
    // 更多生产指标数据...
  ],

  // 告警信息
  "alarms": [
    {
      "id": "a001",
      "device": "1号水泵",
      "message": "电流过高",
      "level": "warning", // warning, error
      "time": "2023-05-20T07:15:00Z"
    },
    // 更多告警...
  ]
}
```

#### 2.1.2 数据更新策略

- **页面初始加载**：组件挂载时获取完整数据
  ```javascript
  useEffect(() => {
    fetchSiteDetail();
  }, []);
  ```

- **用户手动刷新**：点击刷新按钮或下拉刷新
  ```javascript
  const handleRefresh = () => {
    setLoading(true);
    fetchSiteDetail().finally(() => {
      setLoading(false);
      setLastUpdateTime(new Date());
      message.success('数据已刷新');
    });
  };
  ```

- **定时自动刷新**：设置定时器定期刷新数据
  ```javascript
  useEffect(() => {
    const timer = setInterval(() => {
      fetchSiteDetail(true); // 静默刷新，不显示加载状态
    }, 60000); // 每60秒刷新一次

    return () => clearInterval(timer);
  }, []);
  ```

- **页面获得焦点时刷新**：用户切换回页面时刷新数据
  ```javascript
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible') {
        fetchSiteDetail(true);
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);
    return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
  }, []);
  ```

### 2.2 WebSocket（设备控制）

WebSocket主要用于设备控制命令的发送和接收反馈：

```javascript
// 使用WebSocketContext提供的连接
const { connected, connect, lastMessage, sendMessage } = useWebSocket();
```

#### 2.2.1 WebSocket连接管理

WebSocket连接通过自定义Hook `useWebSocket` 进行管理：

```javascript
// WebSocketContext.js
export const WebSocketProvider = ({ children }) => {
  const [socket, setSocket] = useState(null);
  const [connected, setConnected] = useState(false);
  const [lastMessage, setLastMessage] = useState(null);
  const [reconnectAttempts, setReconnectAttempts] = useState(0);
  const maxReconnectAttempts = 5;

  // 连接WebSocket
  const connect = useCallback((url) => {
    if (socket) {
      socket.close();
    }

    try {
      const newSocket = new WebSocket(url);

      newSocket.onopen = () => {
        console.log('WebSocket连接已建立');
        setConnected(true);
        setReconnectAttempts(0);
      };

      newSocket.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          setLastMessage(data);
        } catch (error) {
          console.error('解析WebSocket消息失败:', error);
        }
      };

      newSocket.onclose = () => {
        console.log('WebSocket连接已关闭');
        setConnected(false);

        // 实现重连逻辑
        if (reconnectAttempts < maxReconnectAttempts) {
          const timeout = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
          setTimeout(() => {
            setReconnectAttempts(prev => prev + 1);
            connect(url);
          }, timeout);
        }
      };

      newSocket.onerror = (error) => {
        console.error('WebSocket错误:', error);
      };

      setSocket(newSocket);
    } catch (error) {
      console.error('创建WebSocket连接失败:', error);
    }
  }, [socket, reconnectAttempts]);

  // 发送消息
  const sendMessage = useCallback((message) => {
    if (socket && connected) {
      socket.send(JSON.stringify(message));
      return true;
    }
    return false;
  }, [socket, connected]);

  // 关闭连接
  const disconnect = useCallback(() => {
    if (socket) {
      socket.close();
      setSocket(null);
    }
  }, [socket]);

  // 组件卸载时关闭连接
  useEffect(() => {
    return () => {
      if (socket) {
        socket.close();
      }
    };
  }, [socket]);

  return (
    <WebSocketContext.Provider value={{ connected, connect, lastMessage, sendMessage, disconnect }}>
      {children}
    </WebSocketContext.Provider>
  );
};
```

在站点详情页中使用WebSocket：

```javascript
// 在组件挂载时连接WebSocket
useEffect(() => {
  if (id) {
    connect(`wss://nodered.jzz77.cn:9003/ws/device${id}`);
  }

  return () => {
    disconnect(); // 组件卸载时断开连接
  };
}, [id, connect, disconnect]);

// 监听WebSocket消息
useEffect(() => {
  if (lastMessage) {
    handleWebSocketMessage(lastMessage);
  }
}, [lastMessage]);
```

#### 2.2.2 发送控制命令

1. **设备启停控制**
```javascript
const handleDeviceControl = useCallback((deviceName, action) => {
  if (!connected) {
    message.error('WebSocket未连接，无法控制设备');
    return;
  }

  try {
    // 发送设备控制命令
    sendMessage({
      type: 'command',
      siteId: id,
      deviceName,
      action, // 'start' 或 'stop'
      timestamp: Date.now()
    });

    // 更新UI状态
    setPendingCommands(prev => ({
      ...prev,
      [deviceName]: { status: 'pending', timestamp: Date.now() }
    }));

    message.info(`正在${action === 'start' ? '启动' : '停止'}设备: ${deviceName}`);
  } catch (error) {
    console.error('发送设备控制命令失败:', error);
    message.error('发送控制命令失败');
  }
}, [connected, sendMessage, id]);
```

2. **阀门开关控制**
```javascript
const handleValveControl = useCallback((valveName, action) => {
  if (!connected) {
    message.error('WebSocket未连接，无法控制阀门');
    return;
  }

  try {
    // 发送阀门控制命令
    sendMessage({
      type: 'command',
      siteId: id,
      valveName,
      action, // 'open' 或 'close'
      timestamp: Date.now()
    });

    // 更新UI状态
    setPendingCommands(prev => ({
      ...prev,
      [valveName]: { status: 'pending', timestamp: Date.now() }
    }));

    message.info(`正在${action === 'open' ? '打开' : '关闭'}阀门: ${valveName}`);
  } catch (error) {
    console.error('发送阀门控制命令失败:', error);
    message.error('发送控制命令失败');
  }
}, [connected, sendMessage, id]);
```

3. **频率设置**
```javascript
const handleSetFrequency = useCallback((deviceName, frequency) => {
  if (!connected) {
    message.error('WebSocket未连接，无法设置频率');
    return;
  }

  try {
    // 发送频率设置命令
    sendMessage({
      type: 'command',
      siteId: id,
      deviceName,
      frequency: parseFloat(frequency),
      timestamp: Date.now()
    });

    // 更新UI状态
    setPendingCommands(prev => ({
      ...prev,
      [deviceName]: { status: 'pending', timestamp: Date.now() }
    }));

    message.info(`正在设置设备 ${deviceName} 的频率为 ${frequency} Hz`);
  } catch (error) {
    console.error('发送频率设置命令失败:', error);
    message.error('发送控制命令失败');
  }
}, [connected, sendMessage, id]);
```

#### 2.2.3 接收消息处理

处理WebSocket消息的函数：

```javascript
const handleWebSocketMessage = useCallback((data) => {
  if (!data || !data.type) return;

  switch (data.type) {
    case 'pong':
      // 心跳响应，更新连接状态
      setLastHeartbeatTime(Date.now());
      break;

    case 'device_status':
      // 完整设备状态更新
      if (data.devices) {
        setSite(prev => ({
          ...prev,
          devices: data.devices,
          deviceFrequency: data.deviceFrequency || prev.deviceFrequency,
          isValve: data.isValve || prev.isValve
        }));
      }
      break;

    case 'device_status_change':
      // 增量设备状态更新
      if (data.deviceName && data.status !== undefined) {
        setSite(prev => {
          const updatedDevices = prev.devices.map(device =>
            device.name === data.deviceName
              ? { ...device, status: data.status }
              : device
          );
          return { ...prev, devices: updatedDevices };
        });
      }
      break;

    case 'command_feedback':
      // 命令执行反馈
      const targetId = data.deviceId || data.deviceName || data.valveName;
      if (targetId) {
        setPendingCommands(prev => ({
          ...prev,
          [targetId]: {
            status: data.success ? 'success' : 'error',
            message: data.message || (data.success ? '操作成功' : '操作失败'),
            timestamp: Date.now()
          }
        }));

        // 显示反馈消息
        if (data.success) {
          message.success(data.message || '操作成功');
        } else {
          message.error(data.message || '操作失败');
        }
      }
      break;

    case 'device_event':
      // 设备事件（报警、故障等）
      if (data.eventType === 'alarm') {
        // 添加新告警
        setSite(prev => ({
          ...prev,
          alarms: [
            {
              id: `alarm_${Date.now()}`,
              device: data.deviceName,
              message: data.message,
              level: data.level || 'warning',
              time: new Date().toISOString()
            },
            ...prev.alarms
          ]
        }));

        // 显示告警通知
        notification.warning({
          message: `设备告警: ${data.deviceName}`,
          description: data.message,
          duration: 0
        });
      }
      break;

    default:
      console.log('未处理的WebSocket消息类型:', data.type);
  }
}, []);
```

#### 2.2.4 心跳机制

每15秒发送一次心跳，保持WebSocket连接活跃：

```javascript
// 心跳机制
useEffect(() => {
  let heartbeatInterval;

  if (connected) {
    // 设置心跳间隔，每15秒发送一次
    heartbeatInterval = setInterval(() => {
      try {
        sendMessage({
          type: 'ping',
          timestamp: Date.now(),
          siteId: id,
          clientId: `web_${Math.random().toString(36).substring(7)}`
        });
      } catch (e) {
        console.error('发送心跳失败:', e);
      }
    }, 15000);
  }

  return () => {
    if (heartbeatInterval) {
      clearInterval(heartbeatInterval);
    }
  };
}, [connected, sendMessage, id]);
```

#### 2.2.5 命令超时处理

设置命令执行超时处理，避免用户长时间等待：

```javascript
// 监控命令执行状态，处理超时
useEffect(() => {
  const timeoutIds = {};

  // 为每个pending状态的命令设置超时
  Object.entries(pendingCommands).forEach(([deviceId, command]) => {
    if (command.status === 'pending') {
      timeoutIds[deviceId] = setTimeout(() => {
        setPendingCommands(prev => ({
          ...prev,
          [deviceId]: {
            status: 'timeout',
            message: '响应超时，请检查设备状态',
            timestamp: Date.now()
          }
        }));

        message.warning(`设备 ${deviceId} 控制命令响应超时`);
      }, 10000); // 10秒超时
    }
  });

  return () => {
    // 清除所有超时计时器
    Object.values(timeoutIds).forEach(id => clearTimeout(id));
  };
}, [pendingCommands]);
```

## 3. 页面布局与数据流

### 3.1 页面整体结构

站点详情页面采用卡片式布局，将四个主要部分垂直排列：

```jsx
// SiteDetail.jsx
return (
  <div className={styles.siteDetailContainer}>
    {/* 页面头部 */}
    <div className={styles.header}>
      <div className={styles.backButton}>
        <Button icon={<LeftOutlined />} onClick={() => navigate('/sites')}>
          返回
        </Button>
      </div>
      <h1 className={styles.pageTitle}>{site.name}</h1>
      <div className={styles.actions}>
        <Button
          type="primary"
          icon={<ReloadOutlined />}
          loading={loading}
          onClick={handleRefresh}
        >
          刷新
        </Button>
      </div>
    </div>

    {/* 第一部分：站点信息 */}
    <Card
      title={
        <div style={{ display: 'flex', alignItems: 'center', color: '#2E7D32' }}>
          <AppstoreOutlined style={{ marginRight: 8 }} />
          <span>站点信息</span>
          <Tag color="green" style={{ marginLeft: 8 }}>站点列表传入</Tag>
        </div>
      }
      className={styles.sectionCard}
    >
      {/* 站点信息内容 */}
    </Card>

    {/* 第二部分：设备信息 */}
    <Card
      title={
        <div style={{ display: 'flex', alignItems: 'center', color: '#2E7D32' }}>
          <ApartmentOutlined style={{ marginRight: 8 }} />
          <span>设备信息</span>
          <Tag color="blue" style={{ marginLeft: 8 }}>WebSocket控制</Tag>
        </div>
      }
      className={styles.sectionCard}
    >
      {/* 设备信息内容 */}
    </Card>

    {/* 第三部分：实时数据 */}
    <Card
      title={
        <div style={{ display: 'flex', alignItems: 'center', color: '#2E7D32' }}>
          <DashboardOutlined style={{ marginRight: 8 }} />
          <span>实时数据</span>
          <Tag color="blue" style={{ marginLeft: 8 }}>API推送</Tag>
        </div>
      }
      className={styles.sectionCard}
    >
      {/* 实时数据内容 */}
    </Card>

    {/* 第四部分：告警信息和历史趋势 */}
    <Card
      title={
        <div style={{ display: 'flex', alignItems: 'center', color: '#2E7D32' }}>
          <AlertOutlined style={{ marginRight: 8 }} />
          <span>告警信息和历史趋势</span>
          <Tag color="green" style={{ marginLeft: 8 }}>API调用</Tag>
        </div>
      }
      className={styles.sectionCard}
    >
      {/* 告警信息和历史趋势内容 */}
    </Card>
  </div>
);
```

### 3.2 站点信息区（第一部分）

#### 3.2.1 数据来源与更新

- **数据来源**：从站点列表页面传入的路由参数和API获取的详细信息
- **更新方式**：页面加载时一次性获取，不需要实时更新
- **数据流向**：路由参数 → 组件状态 → 渲染UI

#### 3.2.2 组件实现

```jsx
// 站点基本信息卡片
<Row gutter={[16, 16]}>
  <Col xs={24} md={12}>
    <Descriptions title="基本信息" bordered column={1}>
      <Descriptions.Item label="站点名称">{site.name}</Descriptions.Item>
      <Descriptions.Item label="站点状态">
        <Badge
          status={
            site.status === 'normal'
              ? 'success'
              : site.status === 'warning'
              ? 'warning'
              : site.status === 'error'
              ? 'error'
              : 'default'
          }
          text={
            site.status === 'normal'
              ? '正常'
              : site.status === 'warning'
              ? '警告'
              : site.status === 'error'
              ? '错误'
              : '离线'
          }
        />
      </Descriptions.Item>
      <Descriptions.Item label="处理能力">
        {site.capacity} {site.capacityUnit}
      </Descriptions.Item>
      <Descriptions.Item label="地址">
        <div className={styles.addressItem}>
          <EnvironmentOutlined className={styles.addressIcon} />
          {site.address}
        </div>
      </Descriptions.Item>
      <Descriptions.Item label="最后更新">
        {lastUpdateTime ? lastUpdateTime.toLocaleString() : '未知'}
      </Descriptions.Item>
    </Descriptions>
  </Col>
  <Col xs={24} md={12}>
    {site.description && (
      <>
        <h3 style={{ color: '#2E7D32', display: 'flex', alignItems: 'center' }}>
          <AppstoreOutlined style={{ marginRight: 8 }} />
          站点描述
        </h3>
        <p className={styles.siteDescription}>{site.description}</p>
      </>
    )}
  </Col>
</Row>

// 站点统计卡片
<Row gutter={[16, 16]} className={styles.statsRow}>
  <Col xs={24} sm={12} md={6}>
    <Card>
      <Statistic
        title="设备总数"
        value={site.devices ? site.devices.length : 0}
        prefix={<ApartmentOutlined />}
        valueStyle={{ color: '#2E7D32' }}
      />
    </Card>
  </Col>
  <Col xs={24} sm={12} md={6}>
    <Card>
      <Statistic
        title="运行中设备"
        value={
          site.devices
            ? site.devices.filter(device => device.status === 'running').length
            : 0
        }
        prefix={<DashboardOutlined />}
        valueStyle={{ color: '#52c41a' }}
      />
    </Card>
  </Col>
  <Col xs={24} sm={12} md={6}>
    <Card>
      <Statistic
        title="告警总数"
        value={site.alarms ? site.alarms.length : 0}
        prefix={<AlertOutlined />}
        valueStyle={{ color: site.alarms && site.alarms.length > 0 ? '#ff4d4f' : '#2E7D32' }}
      />
    </Card>
  </Col>
  <Col xs={24} sm={12} md={6}>
    <Card>
      <Statistic
        title="总进水量"
        value={site.totalInflow || 0}
        suffix="m³"
        precision={2}
        prefix={<DashboardOutlined />}
        valueStyle={{ color: '#1890ff' }}
      />
    </Card>
  </Col>
</Row>
```

### 3.3 设备信息区（第二部分）

#### 3.3.1 数据来源与更新

- **数据来源**：通过API获取初始数据
- **控制方式**：通过WebSocket发送控制命令
- **数据流向**：API → 组件状态 → 渲染UI → 用户操作 → WebSocket命令 → 服务器处理 → WebSocket反馈 → 更新UI

#### 3.3.2 组件实现

```jsx
// WebSocket连接状态
<div className={styles.connectionStatus}>
  <Badge
    status={connected ? 'success' : 'error'}
    text={connected ? '设备控制已连接' : '设备控制未连接'}
  />
  {!connected && (
    <Button
      type="primary"
      size="small"
      onClick={connect}
      style={{ marginLeft: 16 }}
    >
      连接
    </Button>
  )}
</div>

// 设备控制卡片
<Row gutter={[16, 16]}>
  {site.devices && site.devices.map(device => (
    <Col xs={24} sm={12} md={8} lg={6} key={device.id || device.name}>
      <Card
        hoverable
        style={{
          borderTop: '4px solid',
          borderTopColor: device.status === 'running' ? '#52c41a' : '#ff4d4f'
        }}
      >
        <div style={{ marginBottom: 8 }}>
          <Text strong>{device.name}</Text>
          <Badge
            status={device.status === 'running' ? 'success' : 'error'}
            text={device.status === 'running' ? '运行中' : '已停止'}
            style={{ float: 'right' }}
          />
        </div>

        {device.location && (
          <div style={{ marginBottom: 8, color: 'rgba(0, 0, 0, 0.45)' }}>
            <EnvironmentOutlined style={{ marginRight: 4 }} />
            {device.location}
          </div>
        )}

        <div style={{ marginTop: 16 }}>
          <Button
            type="primary"
            style={{ backgroundColor: '#52c41a', marginRight: 8 }}
            disabled={device.status === 'running'}
            onClick={() => handleDeviceControl(device.name, 'start')}
            loading={pendingCommands[device.name]?.status === 'pending'}
          >
            启动
          </Button>
          <Button
            danger
            disabled={device.status !== 'running'}
            onClick={() => handleDeviceControl(device.name, 'stop')}
            loading={pendingCommands[device.name]?.status === 'pending'}
          >
            停止
          </Button>
        </div>

        {pendingCommands[device.name]?.status === 'error' && (
          <div style={{ marginTop: 8, color: '#ff4d4f' }}>
            {pendingCommands[device.name].message}
          </div>
        )}
      </Card>
    </Col>
  ))}
</Row>
```

### 3.4 实时数据区（第三部分）

#### 3.4.1 数据来源与更新

- **数据来源**：通过API获取
- **更新方式**：用户手动刷新或定时更新
- **数据流向**：API → 组件状态 → 数据类型判断 → 选择渲染组件 → 渲染UI

#### 3.4.2 数据类型适配

实时数据区支持多种数据类型，根据数据的`dataType`字段选择不同的渲染方式：

1. **基础数据类型**

   - **数值型(number)**：如流量、温度、压力等
     - 使用`Statistic`组件显示，保留两位小数，显示单位
     - 支持范围检查，超出范围时使用警告色

   - **布尔型(boolean)**：如开关状态、阀门状态等
     - 使用`Badge`组件显示状态指示器和文本
     - 根据值显示不同的状态颜色和文本

   - **枚举型(enum)**：如水质等级、设备状态等
     - 使用`Tag`组件显示，根据值选择不同的颜色
     - 通过`enumValues`映射值到标签和颜色

   - **字符串型(string)**：如备注、描述等
     - 直接显示文本内容
     - 长文本可折叠显示

2. **特殊数据类型**

   - **能耗数据(energy)**：设备能耗统计
     - 使用多个`Statistic`组件组合显示电流、电压、功率等
     - 使用进度条显示能耗占比
     - 支持历史能耗趋势图表

   - **运行时间数据(runtime)**：设备运行时间统计
     - 使用`Statistic`组件显示运行时间
     - 使用进度条显示运行时间占比
     - 显示启动次数和最后启动时间

   - **工艺参数(process)**：工艺参数监控
     - 根据参数类型选择不同的显示方式
     - 支持参数调整和设定值显示
     - 使用进度条显示参数在范围内的位置

   - **化验数据(lab)**：水质化验结果
     - 使用`Statistic`组件显示化验值
     - 显示采样时间和报告时间
     - 与标准值对比，超标显示警告

   - **设备健康(health)**：设备健康状态
     - 使用仪表盘显示健康得分
     - 显示下次维护时间和已知问题
     - 使用不同颜色表示健康状态

   - **生产指标(production)**：处理生产指标
     - 使用`Statistic`组件显示指标值
     - 与目标值对比，显示完成率
     - 支持历史趋势图表

#### 3.4.3 动态渲染实现

```jsx
// 导入必要的组件
import { Row, Col, Card, Tabs, Badge, Button, Spin, Empty, Statistic, Descriptions,
  Alert, message, Tag, Divider, List, Input, Typography, Progress } from 'antd';
import {
  DashboardOutlined, ThunderboltOutlined, ClockCircleOutlined, SettingOutlined,
  ExperimentOutlined, HeartOutlined, FundOutlined, AppstoreOutlined,
  AlertOutlined, LineChartOutlined, EnvironmentOutlined
} from '@ant-design/icons';
const { Text } = Typography;

// 数据卡片组件 - 根据数据类型动态渲染
const DataCard = ({ data }) => {
  if (!data) return null;

  // 根据数据类型选择渲染方式
  const renderContent = () => {
    // 基础数据类型
    switch (data.dataType) {
      case 'number':
        return (
          <Statistic
            value={data.data?.toFixed(2) || '0.00'}
            suffix={data.dw || data.unit || ''}
            precision={2}
            valueStyle={{
              color: data.alarm === 1 ? '#ff4d4f' :
                     (data.min !== undefined && data.data < data.min) ||
                     (data.max !== undefined && data.data > data.max) ?
                     '#faad14' : '#1890ff'
            }}
          />
        );
      case 'boolean':
        return (
          <Badge
            status={data.data === 1 ? 'success' : 'default'}
            text={data.data === 1 ? '开启' : '关闭'}
          />
        );
      case 'enum':
        const enumValue = data.enumValues?.[data.data];
        return (
          <Tag color={enumValue?.color || 'blue'}>
            {enumValue?.label || data.data}
          </Tag>
        );

      // 特殊数据类型
      case 'energy':
        return renderEnergyData(data);
      case 'runtime':
        return renderRuntimeData(data);
      case 'process':
        return renderProcessData(data);
      case 'lab':
        return renderLabData(data);
      case 'health':
        return renderHealthData(data);
      case 'production':
        return renderProductionData(data);
      default:
        return <Text>{data.data || data.value}</Text>;
    }
  };

  // 渲染能耗数据
  const renderEnergyData = (data) => (
    <div>
      <Row gutter={[8, 8]}>
        <Col span={12}>
          <Statistic
            title="电流"
            value={data.current}
            suffix="A"
            precision={1}
            valueStyle={{ fontSize: 14 }}
          />
        </Col>
        <Col span={12}>
          <Statistic
            title="电压"
            value={data.voltage}
            suffix="V"
            precision={0}
            valueStyle={{ fontSize: 14 }}
          />
        </Col>
      </Row>
      <Divider style={{ margin: '8px 0' }} />
      <Statistic
        title="功率"
        value={data.power}
        suffix="kW"
        precision={1}
        valueStyle={{ color: '#1890ff' }}
      />
      <div style={{ marginTop: 8 }}>
        <Text type="secondary">累计耗电: {data.consumption} {data.unit}</Text>
      </div>
    </div>
  );

  // 渲染运行时间数据
  const renderRuntimeData = (data) => (
    <div>
      <Statistic
        title="运行时间"
        value={data.runningTime}
        suffix={data.unit}
        precision={1}
        valueStyle={{ color: '#1890ff' }}
      />
      <div style={{ marginTop: 8 }}>
        <Text type="secondary">启动次数: {data.startCount} 次</Text>
      </div>
      <div style={{ marginTop: 4 }}>
        <Text type="secondary">
          最后启动: {new Date(data.lastStartTime).toLocaleString()}
        </Text>
      </div>
    </div>
  );

  // 渲染工艺参数数据
  const renderProcessData = (data) => {
    if (data.dataType === 'enum') {
      const enumValue = data.enumValues?.[data.value];
      return (
        <div>
          <div style={{ marginBottom: 8 }}>
            <Text strong>{data.name}</Text>
          </div>
          <Tag color={enumValue?.color || 'blue'} style={{ padding: '4px 8px', fontSize: 16 }}>
            {enumValue?.label || data.value}
          </Tag>
        </div>
      );
    }

    return (
      <div>
        <Statistic
          value={data.value}
          suffix={data.unit}
          precision={0}
          valueStyle={{ color: '#1890ff' }}
        />
        {data.min !== undefined && data.max !== undefined && (
          <div style={{ marginTop: 8 }}>
            <Progress
              percent={((data.value - data.min) / (data.max - data.min)) * 100}
              size="small"
              status={data.alarm === 1 ? 'exception' : 'normal'}
            />
            <div style={{ fontSize: 12, color: 'rgba(0, 0, 0, 0.45)' }}>
              范围: {data.min} - {data.max} {data.unit}
            </div>
          </div>
        )}
      </div>
    );
  };

  // 渲染化验数据
  const renderLabData = (data) => (
    <div>
      <Statistic
        value={data.value}
        suffix={data.unit}
        precision={1}
        valueStyle={{
          color: data.standard && data.value > data.standard ? '#ff4d4f' : '#1890ff'
        }}
      />
      {data.standard && (
        <div style={{ marginTop: 4 }}>
          <Text type="secondary">标准值: {data.standard} {data.unit}</Text>
        </div>
      )}
      <div style={{ marginTop: 4, fontSize: 12, color: 'rgba(0, 0, 0, 0.45)' }}>
        采样时间: {new Date(data.sampleTime).toLocaleString()}
      </div>
    </div>
  );

  // 渲染设备健康状态
  const renderHealthData = (data) => (
    <div>
      <Statistic
        title="健康得分"
        value={data.healthScore}
        suffix="/100"
        precision={0}
        valueStyle={{
          color:
            data.healthScore >= 80 ? '#52c41a' :
            data.healthScore >= 60 ? '#1890ff' :
            data.healthScore >= 40 ? '#faad14' : '#ff4d4f'
        }}
      />
      <div style={{ marginTop: 8 }}>
        <Badge
          status={
            data.status === 'good' ? 'success' :
            data.status === 'normal' ? 'processing' :
            data.status === 'warning' ? 'warning' : 'error'
          }
          text={
            data.status === 'good' ? '状态良好' :
            data.status === 'normal' ? '状态正常' :
            data.status === 'warning' ? '需要注意' : '需要维修'
          }
        />
      </div>
      {data.maintenanceDue && (
        <div style={{ marginTop: 4, fontSize: 12, color: 'rgba(0, 0, 0, 0.45)' }}>
          下次维护: {data.maintenanceDue}
        </div>
      )}
    </div>
  );

  // 渲染生产指标
  const renderProductionData = (data) => (
    <div>
      <Statistic
        value={data.value}
        suffix={data.unit}
        precision={data.unit === '%' ? 1 : 0}
        valueStyle={{ color: '#1890ff' }}
      />
      {data.target && (
        <div style={{ marginTop: 8 }}>
          <Progress
            percent={(data.value / data.target) * 100}
            size="small"
            status={
              (data.value / data.target) >= 1 ? 'success' :
              (data.value / data.target) >= 0.8 ? 'normal' : 'exception'
            }
          />
          <div style={{ fontSize: 12, color: 'rgba(0, 0, 0, 0.45)' }}>
            目标: {data.target} {data.unit} ({((data.value / data.target) * 100).toFixed(1)}%)
          </div>
        </div>
      )}
    </div>
  );
  };

  return (
    <Card
      hoverable
      style={{
        borderTop: '4px solid',
        borderTopColor: data.alarm === 1 ? '#ff4d4f' : '#1890ff'
      }}
    >
      <div style={{ marginBottom: 8 }}>
        <Text strong>{data.name}</Text>
      </div>
      {renderContent()}
      {data.alarm === 1 && (
        <Tag color="error" style={{ marginTop: 8 }}>异常</Tag>
      )}
    </Card>
  );
};

// 条件渲染 - 根据数据类型显示不同的数据区域
// 传感器数据 - 进水数据
{site.inData && site.inData.length > 0 && (
  <>
    <h3 style={{ color: '#2E7D32', display: 'flex', alignItems: 'center', marginBottom: 16 }}>
      <DashboardOutlined style={{ marginRight: 8 }} />
      进水数据
    </h3>
    <Row gutter={[16, 16]}>
      {site.inData.map((item, index) => (
        <Col xs={24} sm={12} md={8} lg={6} key={`indata-${index}`}>
          <DataCard data={item} />
        </Col>
      ))}
    </Row>
  </>
)}

// 传感器数据 - 出水数据
{site.outData && site.outData.length > 0 && (
  <>
    <Divider />
    <h3 style={{ color: '#2E7D32', display: 'flex', alignItems: 'center', marginBottom: 16 }}>
      <DashboardOutlined style={{ marginRight: 8 }} />
      出水数据
    </h3>
    <Row gutter={[16, 16]}>
      {site.outData.map((item, index) => (
        <Col xs={24} sm={12} md={8} lg={6} key={`outdata-${index}`}>
          <DataCard data={item} />
        </Col>
      ))}
    </Row>
  </>
)}

// 能耗监控数据
{site.energy_stats && site.energy_stats.length > 0 && (
  <>
    <Divider />
    <h3 style={{ color: '#2E7D32', display: 'flex', alignItems: 'center', marginBottom: 16 }}>
      <ThunderboltOutlined style={{ marginRight: 8 }} />
      能耗监控
    </h3>
    <Row gutter={[16, 16]}>
      {site.energy_stats.map((item, index) => (
        <Col xs={24} sm={12} md={8} lg={6} key={`energy-${index}`}>
          <DataCard data={item} />
        </Col>
      ))}
    </Row>
  </>
)}

// 设备运行时间数据
{site.equipments && site.equipments.length > 0 && (
  <>
    <Divider />
    <h3 style={{ color: '#2E7D32', display: 'flex', alignItems: 'center', marginBottom: 16 }}>
      <ClockCircleOutlined style={{ marginRight: 8 }} />
      设备运行时间
    </h3>
    <Row gutter={[16, 16]}>
      {site.equipments.map((item, index) => (
        <Col xs={24} sm={12} md={8} lg={6} key={`equipment-${index}`}>
          <DataCard data={item} />
        </Col>
      ))}
    </Row>
  </>
)}

// 工艺参数数据
{site.process_parameters && site.process_parameters.length > 0 && (
  <>
    <Divider />
    <h3 style={{ color: '#2E7D32', display: 'flex', alignItems: 'center', marginBottom: 16 }}>
      <SettingOutlined style={{ marginRight: 8 }} />
      工艺参数
    </h3>
    <Row gutter={[16, 16]}>
      {site.process_parameters.map((item, index) => (
        <Col xs={24} sm={12} md={8} lg={6} key={`process-${index}`}>
          <DataCard data={item} />
        </Col>
      ))}
    </Row>
  </>
)}

// 化验数据
{site.lab_results && site.lab_results.length > 0 && (
  <>
    <Divider />
    <h3 style={{ color: '#2E7D32', display: 'flex', alignItems: 'center', marginBottom: 16 }}>
      <ExperimentOutlined style={{ marginRight: 8 }} />
      水质化验
    </h3>
    <Row gutter={[16, 16]}>
      {site.lab_results.map((item, index) => (
        <Col xs={24} sm={12} md={8} lg={6} key={`lab-${index}`}>
          <DataCard data={item} />
        </Col>
      ))}
    </Row>
  </>
)}

// 设备健康状态
{site.equipment_health && site.equipment_health.length > 0 && (
  <>
    <Divider />
    <h3 style={{ color: '#2E7D32', display: 'flex', alignItems: 'center', marginBottom: 16 }}>
      <HeartOutlined style={{ marginRight: 8 }} />
      设备健康
    </h3>
    <Row gutter={[16, 16]}>
      {site.equipment_health.map((item, index) => (
        <Col xs={24} sm={12} md={8} lg={6} key={`health-${index}`}>
          <DataCard data={item} />
        </Col>
      ))}
    </Row>
  </>
)}

// 生产指标
{site.production_metrics && site.production_metrics.length > 0 && (
  <>
    <Divider />
    <h3 style={{ color: '#2E7D32', display: 'flex', alignItems: 'center', marginBottom: 16 }}>
      <FundOutlined style={{ marginRight: 8 }} />
      生产指标
    </h3>
    <Row gutter={[16, 16]}>
      {site.production_metrics.map((item, index) => (
        <Col xs={24} sm={12} md={8} lg={6} key={`production-${index}`}>
          <DataCard data={item} />
        </Col>
      ))}
    </Row>
  </>
)}
```

### 3.5 告警信息和历史趋势区（第四部分）

#### 3.5.1 数据来源与更新

- **数据来源**：通过API调用获取
- **更新方式**：用户手动刷新或定时更新
- **数据流向**：API → 组件状态 → 渲染UI

#### 3.5.2 组件实现

```jsx
<Tabs activeKey={activeTab} onChange={setActiveTab}>
  <Tabs.TabPane
    tab={
      <span>
        <AlertOutlined />
        告警记录
      </span>
    }
    key="alarms"
  >
    {site.alarms && site.alarms.length > 0 ? (
      site.alarms.map((alarm, index) => (
        <Alert
          key={index}
          message={`${alarm.device}: ${alarm.message}`}
          description={`时间: ${alarm.time}`}
          type={alarm.level === 'error' ? 'error' : 'warning'}
          showIcon
          className={styles.alarmAlert}
          style={{ marginBottom: 16 }}
        />
      ))
    ) : (
      <Empty description="暂无告警记录" />
    )}
  </Tabs.TabPane>

  <Tabs.TabPane
    tab={
      <span>
        <LineChartOutlined />
        数据趋势
      </span>
    }
    key="data"
  >
    <div className={styles.chartSection}>
      <Empty description="数据趋势功能开发中..." />
    </div>
  </Tabs.TabPane>

  <Tabs.TabPane
    tab={
      <span>
        <TeamOutlined />
        管理部门
      </span>
    }
    key="departments"
  >
    {site.departments && site.departments.length > 0 ? (
      <List
        bordered
        dataSource={site.departments}
        renderItem={(item) => (
          <List.Item>
            <TeamOutlined style={{ marginRight: 8, color: '#2E7D32' }} />
            {item}
          </List.Item>
        )}
      />
    ) : (
      <Empty description="暂无管理部门信息" />
    )}
  </Tabs.TabPane>
</Tabs>
```

## 4. 错误处理与容错机制

### 4.1 WebSocket连接管理

#### 4.1.1 连接状态监控

```javascript
// 在UI中显示连接状态
<div className={styles.connectionStatus}>
  <Badge
    status={connected ? 'success' : 'error'}
    text={connected ? '设备控制已连接' : '设备控制未连接'}
  />
  {!connected && (
    <Button
      type="primary"
      size="small"
      onClick={connect}
      style={{ marginLeft: 16 }}
    >
      连接
    </Button>
  )}
</div>

// 监控连接状态变化
useEffect(() => {
  if (connected) {
    message.success('WebSocket连接已建立');
  } else if (reconnectAttempts > 0) {
    message.error('WebSocket连接已断开，正在尝试重连...');
  }
}, [connected, reconnectAttempts]);
```

#### 4.1.2 自动重连机制

WebSocket连接断开时，使用指数退避策略自动重连：

```javascript
// 在WebSocketContext中实现
newSocket.onclose = () => {
  console.log('WebSocket连接已关闭');
  setConnected(false);

  // 实现重连逻辑
  if (reconnectAttempts < maxReconnectAttempts) {
    // 指数退避策略：等待时间随重连次数增加而增加
    const timeout = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
    setTimeout(() => {
      setReconnectAttempts(prev => prev + 1);
      connect(url);
    }, timeout);
  } else {
    message.error('WebSocket连接失败，请手动重连');
  }
};
```

#### 4.1.3 手动重连

提供手动重连按钮，允许用户在自动重连失败后手动触发重连：

```javascript
const handleManualReconnect = () => {
  setReconnectAttempts(0); // 重置重连计数
  connect(`wss://nodered.jzz77.cn:9003/ws/device${id}`);
  message.info('正在尝试重新连接...');
};
```

### 4.2 命令执行反馈

#### 4.2.1 命令状态跟踪

使用状态管理命令执行状态：

```javascript
// 定义命令状态
const [pendingCommands, setPendingCommands] = useState({});

// 发送命令时更新状态
setPendingCommands(prev => ({
  ...prev,
  [deviceName]: { status: 'pending', timestamp: Date.now() }
}));

// 接收反馈时更新状态
setPendingCommands(prev => ({
  ...prev,
  [deviceId]: {
    status: data.success ? 'success' : 'error',
    message: data.message || (data.success ? '操作成功' : '操作失败'),
    timestamp: Date.now()
  }
}));
```

#### 4.2.2 命令超时处理

设置命令执行超时处理，避免用户长时间等待：

```javascript
// 为每个pending状态的命令设置超时
Object.entries(pendingCommands).forEach(([deviceId, command]) => {
  if (command.status === 'pending') {
    timeoutIds[deviceId] = setTimeout(() => {
      setPendingCommands(prev => ({
        ...prev,
        [deviceId]: {
          status: 'timeout',
          message: '响应超时，请检查设备状态',
          timestamp: Date.now()
        }
      }));

      message.warning(`设备 ${deviceId} 控制命令响应超时`);
    }, 10000); // 10秒超时
  }
});
```

#### 4.2.3 用户反馈

根据命令执行状态提供视觉反馈：

```javascript
// 按钮加载状态
<Button
  type="primary"
  loading={pendingCommands[device.name]?.status === 'pending'}
  onClick={() => handleDeviceControl(device.name, 'start')}
>
  启动
</Button>

// 错误消息显示
{pendingCommands[device.name]?.status === 'error' && (
  <div style={{ marginTop: 8, color: '#ff4d4f' }}>
    {pendingCommands[device.name].message}
  </div>
)}

// 全局消息通知
if (data.success) {
  message.success(data.message || '操作成功');
} else {
  message.error(data.message || '操作失败');
}
```

### 4.3 API错误处理

#### 4.3.1 请求错误处理

```javascript
const fetchSiteDetail = async (silent = false) => {
  if (!silent) {
    setLoading(true);
  }

  try {
    const response = await api.get(`/api/sites/${id}`);
    setSite(response.data);
    setLastUpdateTime(new Date());
    return response.data;
  } catch (error) {
    console.error('获取站点详情失败:', error);
    message.error('获取站点详情失败，请稍后重试');
    return null;
  } finally {
    if (!silent) {
      setLoading(false);
    }
  }
};
```

#### 4.3.2 数据验证

在使用API返回的数据前进行验证：

```javascript
// 数据验证
useEffect(() => {
  if (site) {
    // 确保devices是数组
    if (!Array.isArray(site.devices)) {
      setSite(prev => ({ ...prev, devices: [] }));
    }

    // 确保inData是数组
    if (!Array.isArray(site.inData)) {
      setSite(prev => ({ ...prev, inData: [] }));
    }

    // 确保outData是数组
    if (!Array.isArray(site.outData)) {
      setSite(prev => ({ ...prev, outData: [] }));
    }

    // 确保alarms是数组
    if (!Array.isArray(site.alarms)) {
      setSite(prev => ({ ...prev, alarms: [] }));
    }
  }
}, [site]);
```

## 5. 参考移动端实现

Web端站点详情页的实现参考了移动端的以下特性：

### 5.1 数据获取方式

移动端通过HTTP API获取站点信息、设备状态和实时数据：

```javascript
// 移动端代码
const response = await axios.get(`https://nodered.jzz77.cn:9003/api/sites/site/${siteId}`);
```

Web端采用相同的API调用方式：

```javascript
// Web端代码
const response = await api.get(`/api/sites/${id}`);
```

### 5.2 设备控制方式

移动端通过WebSocket发送控制命令并接收反馈：

```javascript
// 移动端代码
sendCommandWs({
  type: 'device_control',
  deviceName,
  action, // 'start' 或 'stop'
  siteId,
  timestamp: Date.now()
});
```

Web端采用相同的WebSocket通信方式：

```javascript
// Web端代码
sendMessage({
  type: 'command',
  siteId: id,
  deviceName,
  action, // 'start' 或 'stop'
  timestamp: Date.now()
});
```

### 5.3 心跳机制

移动端每15秒发送一次心跳，保持WebSocket连接活跃：

```javascript
// 移动端代码
globalWSRef.current.send(JSON.stringify({
  type: 'ping',
  timestamp: Date.now(),
  siteId,
  clientId: `mobile_${Platform.OS}_${Math.random().toString(36).substring(7)}`
}));
```

Web端采用相同的心跳机制：

```javascript
// Web端代码
sendMessage({
  type: 'ping',
  timestamp: Date.now(),
  siteId: id,
  clientId: `web_${Math.random().toString(36).substring(7)}`
});
```

### 5.4 数据展示方式与布局适配

移动端和Web端都实现了基于数据类型的动态渲染和条件显示，确保界面的整洁和一致性：

1. **数据类型适配**：根据数据类型（数值型、布尔型、枚举型、字符串型）选择合适的渲染组件
2. **条件渲染**：只有当相应数据存在时才渲染对应组件
3. **分组显示**：根据数据类型分组显示，如进水数据、出水数据、设备状态等
4. **空状态处理**：当数据不存在时显示适当的空状态提示

Web端在保持与移动端相同的动态渲染逻辑的同时，针对大屏幕进行了布局优化：

1. **响应式布局**：使用栅格系统适应不同屏幕尺寸
2. **卡片布局**：使用卡片形式展示数据，提高可读性
3. **分组展示**：将相关数据分组展示，提高信息组织的清晰度

### 5.5 错误处理

移动端实现了完善的错误处理和用户反馈机制，Web端也采用了相同的策略，包括连接状态显示、命令执行反馈和超时处理等。

## 6. 通信端点总结

### 6.1 HTTP API端点

1. **获取站点详情**
   - URL: `https://nodered.jzz77.cn:9003/api/sites/site/${id}`
   - 方法: GET
   - 用途: 获取站点信息、设备状态和实时数据
   - 响应格式: JSON
   - 主要字段: `devices`, `deviceFrequency`, `inData`, `outData`, `isValve`, `departments`, `alarms`

2. **备用控制命令**（WebSocket失败时的备选方案）
   - URL: `https://nodered.jzz77.cn:9003/api/site/${id}/command`
   - 方法: POST
   - 用途: 发送设备控制命令
   - 请求格式: JSON
   - 主要字段: `type`, `deviceName`/`valveName`, `action`/`frequency`

### 6.2 WebSocket连接

- URL: `wss://nodered.jzz77.cn:9003/ws/device${id}`
- 用途: 发送设备控制命令并接收反馈
- 消息格式: JSON
- 主要消息类型:
  - `ping`: 心跳消息
  - `command`: 控制命令
  - `device_status`: 设备状态更新
  - `command_feedback`: 命令执行反馈
  - `device_event`: 设备事件

## 7. 总结

### 7.1 通信策略

站点详情页采用了HTTP API和WebSocket相结合的通信策略：

- **HTTP API**用于获取相对稳定的数据，如站点信息、设备状态和实时数据
- **WebSocket**用于需要低延迟的设备控制命令和反馈

这种通信模式结合了HTTP API的可靠性和WebSocket的实时性，特别适合设备控制这种需要即时反馈的场景。

### 7.2 页面布局

页面的四部分布局清晰地划分了不同类型的数据和功能：

1. **站点信息区**：展示站点基本信息，由站点列表传入
2. **设备信息区**：展示设备状态，提供WebSocket控制功能
3. **实时数据区**：展示实时传感器数据，由API推送
4. **告警信息和历史趋势区**：展示告警记录和历史数据，使用API调用

### 7.3 性能优化

为了提高页面性能和用户体验，实现了以下优化：

1. **按需连接WebSocket**：只在需要控制设备时建立WebSocket连接
2. **定时刷新**：定期刷新数据，保持数据的实时性
3. **静默刷新**：后台刷新数据时不显示加载状态，减少UI闪烁
4. **数据缓存**：缓存已获取的数据，减少不必要的API调用
5. **组件懒加载**：使用React.lazy和Suspense实现组件懒加载

### 7.4 用户角色与权限控制

参考移动端的实现，Web端需要实现完善的用户角色控制和设备操作权限管理：

#### 7.4.1 权限检查机制

```jsx
// 权限检查函数
const checkControlPermission = useCallback(async (forceCheck = false) => {
  // 避免重复检查
  if (checkingPermissionRef.current && !forceCheck) {
    return hasControlPermission;
  }

  checkingPermissionRef.current = true;

  try {
    // 获取当前用户信息
    const user = await getUserInfo();
    if (!user) {
      setHasControlPermission(false);
      return false;
    }

    // 获取站点部门信息
    let currentDepartments = siteDepartments;
    if (!currentDepartments || currentDepartments.length === 0) {
      // 尝试从API获取站点详情
      const siteData = await fetchSiteDetail(true);
      if (siteData?.departments) {
        currentDepartments = siteData.departments;
      }
    }

    // 如果仍然没有部门信息
    if (!currentDepartments || currentDepartments.length === 0) {
      setHasControlPermission(false);
      return false;
    }

    // 管理员始终有权限
    if (user && (user.is_admin === 1 || user.isAdmin === true)) {
      console.log('管理员拥有完全控制权限');
      setHasControlPermission(true);
      return true;
    }

    // 获取用户角色
    const userRoles = await getUserRoles(user.id);

    // 从userRoles中提取角色名称
    const userRoleNames = userRoles.map(role => {
      // role可能是对象或直接是ID
      if (typeof role === 'object' && role !== null) {
        // 从roleMap中获取角色名称
        const roleId = role.id || role.role_id;
        if (roleId) {
          // 角色映射
          const roleMap = {
            1: '管理员',
            2: '部门管理员',
            3: '运行班组',
            4: '化验班组',
            5: '机电班组',
            6: '污泥车间',
            7: '5000吨处理站',
            8: '附属设施',
            9: '备用权限'
          };
          return roleMap[roleId] || role.name;
        }
        return role.name;
      }
      return role; // 如果role直接是名称字符串
    }).filter(name => name); // 移除undefined或null

    // 检查用户角色是否与站点部门匹配
    const hasPermission = userRoleNames.some(roleName =>
      currentDepartments.includes(roleName)
    );

    console.log('权限检查结果:', hasPermission ? '有权限' : '无权限');
    setHasControlPermission(hasPermission);

    return hasPermission;
  } catch (error) {
    console.error('检查权限出错:', error);
    setHasControlPermission(false);
    return false;
  } finally {
    checkingPermissionRef.current = false;
  }
}, [user, userRoles, siteDepartments, fetchSiteDetail]);
```

#### 7.4.2 权限应用

在设备控制、阀门控制和频率设置等功能中应用权限检查：

```jsx
// 设备控制函数
const handleDeviceControl = useCallback((deviceName, action) => {
  // 权限检查
  if (!hasControlPermission) {
    message.error('权限不足，您没有控制此设备的权限');
    return;
  }

  try {
    // 记录操作日志
    logOperation(deviceName, '设备控制', `${action === 'start' ? '启动' : '停止'}设备`);

    // 发送设备控制命令
    sendMessage({
      type: 'command',
      siteId: id,
      deviceName,
      action,
      timestamp: Date.now()
    });

    // 更新UI状态
    setPendingCommands(prev => ({
      ...prev,
      [deviceName]: { status: 'pending', timestamp: Date.now() }
    }));

    message.info(`正在${action === 'start' ? '启动' : '停止'}设备: ${deviceName}`);
  } catch (error) {
    console.error('发送设备控制命令失败:', error);
    message.error('发送控制命令失败');
  }
}, [hasControlPermission, id, sendMessage, logOperation]);
```

#### 7.4.3 权限UI反馈

在UI中显示权限状态，禁用无权限用户的控制按钮：

```jsx
// 设备控制卡片
<Card hoverable style={{ borderTop: '4px solid #1890ff' }}>
  <div style={{ marginBottom: 8 }}>
    <Text strong>{device.name}</Text>
    <Badge
      status={device.status === 'running' ? 'success' : 'error'}
      text={device.status === 'running' ? '运行中' : '已停止'}
      style={{ float: 'right' }}
    />
  </div>

  <div style={{ marginTop: 16 }}>
    <Button
      type="primary"
      style={{ backgroundColor: '#52c41a', marginRight: 8 }}
      disabled={device.status === 'running' || !hasControlPermission}
      onClick={() => handleDeviceControl(device.name, 'start')}
      loading={pendingCommands[device.name]?.status === 'pending'}
    >
      启动
    </Button>
    <Button
      danger
      disabled={device.status !== 'running' || !hasControlPermission}
      onClick={() => handleDeviceControl(device.name, 'stop')}
      loading={pendingCommands[device.name]?.status === 'pending'}
    >
      停止
    </Button>
  </div>

  {!hasControlPermission && (
    <div style={{
      marginTop: 8,
      padding: '4px 8px',
      backgroundColor: 'rgba(0, 0, 0, 0.05)',
      borderRadius: 4,
      color: 'rgba(0, 0, 0, 0.45)',
      fontSize: 12
    }}>
      无控制权限
    </div>
  )}
</Card>
```

#### 7.4.4 权限缓存与更新

为了提高性能，权限检查结果可以缓存，并在特定情况下更新：

1. **初始加载时检查**：页面加载时进行一次权限检查
2. **页面获得焦点时检查**：页面重新获得焦点时检查权限是否变化
3. **用户信息变化时检查**：用户信息或角色变化时重新检查权限
4. **站点信息更新时检查**：站点部门信息更新时重新检查权限

```jsx
// 在用户信息或站点信息变化时重新检查权限
useEffect(() => {
  if (user && siteDepartments?.length > 0) {
    checkControlPermission();
  }
}, [user, siteDepartments, checkControlPermission]);

// 页面获得焦点时检查权限
useEffect(() => {
  const handleVisibilityChange = () => {
    if (document.visibilityState === 'visible') {
      checkControlPermission();
    }
  };

  document.addEventListener('visibilitychange', handleVisibilityChange);
  return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
}, [checkControlPermission]);
```

### 7.5 未来改进

未来可以考虑以下改进：

1. **实现数据趋势图表**：使用ECharts或Recharts实现历史数据趋势图表
2. **优化移动端适配**：进一步优化移动端的布局和交互
3. **添加离线模式**：实现基本的离线功能，在网络不可用时仍能查看缓存的数据
4. **添加推送通知**：使用WebSocket实现实时推送通知
5. **扩展数据类型支持**：增加对图表型、图像型等更多数据类型的支持
6. **自定义数据卡片**：允许用户自定义数据卡片的显示方式和布局
7. **细粒度权限控制**：实现更细粒度的权限控制，如只读权限、特定设备控制权限等
